// ===== Constants and Scaling =====

// The golden ratio.
const phi = (1 + Math.sqrt(5)) / 2;

// In our unscaled six-basis system, a unit step (e.g. [1,0,0,0,0,0]) converts to a Cartesian length ~√(1 + φ²).
// To have the minimal edge length be 0.4, we set:
const unscaledUnit = Math.sqrt(1 + phi * phi); // ~1.902
const s = 0.4 / unscaledUnit;  // scaling factor (≈0.2105)

// ===== Six-Basis Conversion Functions =====

/**
 * Converts an integer six-vector (in the six‑basis system) to scaled Cartesian coordinates.
 *
 * Basis vectors (unscaled):
 *   b1 = ( 0,  1,  φ)
 *   b2 = ( 0, -1,  φ)
 *   b3 = ( 1,  φ,  0)
 *   b4 = (-1,  φ,  0)
 *   b5 = ( φ,  0,  1)
 *   b6 = ( φ,  0, -1)
 *
 * @param {number[]} coords - [c1, c2, c3, c4, c5, c6]
 * @returns {{x: number, y: number, z: number}} Scaled Cartesian coordinates.
 */
function sixBasisToCartesian(coords) {
  const [c1, c2, c3, c4, c5, c6] = coords;
  let x = c3 - c4 + phi * (c5 + c6);
  let y = c1 - c2 + phi * (c3 + c4);
  let z = phi * (c1 + c2) + c5 - c6;
  return { x: s * x, y: s * y, z: s * z };
}

/**
 * Converts scaled Cartesian coordinates to a six‑basis coordinate (using the pseudoinverse).
 *
 * @param {{x: number, y: number, z: number}} point - Scaled Cartesian point.
 * @returns {number[]} [c1, c2, c3, c4, c5, c6] (non-integer, to be rounded for lattice use)
 */
function cartesianToSixBasis(point) {
  const { x, y, z } = point;
  // “Unscale” the coordinates.
  let X = x / s, Y = y / s, Z = z / s;
  const D = 4 + 2 * phi;
  let c1 = (Y + phi * Z) / D;
  let c2 = (-Y + phi * Z) / D;
  let c3 = (X + phi * Y) / D;
  let c4 = (-X + phi * Y) / D;
  let c5 = (phi * X + Z) / D;
  let c6 = (phi * X - Z) / D;
  return [c1, c2, c3, c4, c5, c6];
}

/**
 * Rounds a six‑basis coordinate to the nearest integers.
 *
 * @param {number[]} coords
 * @returns {number[]} Integer six-vector.
 */
function roundSixVector(coords) {
  return coords.map(Math.round);
}

/**
 * Adds two six‑vectors.
 *
 * @param {number[]} a
 * @param {number[]} b
 * @returns {number[]} a + b.
 */
function addSixVectors(a, b) {
  return a.map((val, i) => val + b[i]);
}

/**
 * Snaps a Cartesian point to the nearest six‑basis lattice point.
 *
 * @param {{x: number, y: number, z: number}} point
 * @returns {{six: number[], cartesian: {x:number, y:number, z:number}}}
 */
function snapToSixBasis(point) {
  let coords = cartesianToSixBasis(point);
  let intCoords = roundSixVector(coords);
  return { six: intCoords, cartesian: sixBasisToCartesian(intCoords) };
}

// ===== Geometry for the Tube =====

// Define the tube’s central axis from start to end.
const start = { x: 0, y: 0, z: 0 };
const end = { x: 5, y: 7, z: 8 };

/**
 * Linear interpolation along the line.
 *
 * @param {number} t - Parameter 0 ≤ t ≤ 1.
 * @returns {{x: number, y: number, z: number}}
 */
function interpolateLine(t) {
  return {
    x: start.x + t * (end.x - start.x),
    y: start.y + t * (end.y - start.y),
    z: start.z + t * (end.z - start.z)
  };
}

/**
 * Returns two perpendicular unit vectors in the plane perpendicular to the given direction.
 *
 * @param {{x:number, y:number, z:number}} dir
 * @returns {{v1:{x:number, y:number, z:number}, v2:{x:number, y:number, z:number}}}
 */
function getPerpendicularVectors(dir) {
  let mag = Math.sqrt(dir.x**2 + dir.y**2 + dir.z**2);
  let d = { x: dir.x/mag, y: dir.y/mag, z: dir.z/mag };
  let arbitrary = (Math.abs(d.x) < 0.9) ? { x: 1, y: 0, z: 0 } : { x: 0, y: 1, z: 0 };
  let v1 = {
    x: d.y * arbitrary.z - d.z * arbitrary.y,
    y: d.z * arbitrary.x - d.x * arbitrary.z,
    z: d.x * arbitrary.y - d.y * arbitrary.x
  };
  let magV1 = Math.sqrt(v1.x**2 + v1.y**2 + v1.z**2);
  v1 = { x: v1.x/magV1, y: v1.y/magV1, z: v1.z/magV1 };
  let v2 = {
    x: d.y * v1.z - d.z * v1.y,
    y: d.z * v1.x - d.x * v1.z,
    z: d.x * v1.y - d.y * v1.x
  };
  return { v1, v2 };
}

// Precompute a fixed pair of perpendicular vectors from the tube’s axis.
const lineDir = { x: end.x - start.x, y: end.y - start.y, z: end.z - start.z };
const { v1, v2 } = getPerpendicularVectors(lineDir);

// Parameters for sampling along the line.
const numSections = 11;         // Number of sample points along the tube’s axis.
const tubeRadius = 1.0;         // Radius of the envelope (in Cartesian units).

// Define the 12 immediate neighbor directions in the six‑basis lattice.
const neighborDirs = [
  [ 1, 0, 0, 0, 0, 0],
  [-1, 0, 0, 0, 0, 0],
  [0,  1, 0, 0, 0, 0],
  [0, -1, 0, 0, 0, 0],
  [0, 0,  1, 0, 0, 0],
  [0, 0, -1, 0, 0, 0],
  [0, 0, 0,  1, 0, 0],
  [0, 0, 0, -1, 0, 0],
  [0, 0, 0, 0,  1, 0],
  [0, 0, 0, 0, -1, 0],
  [0, 0, 0, 0, 0,  1],
  [0, 0, 0, 0, 0, -1]
];

/**
 * For a given center (unsnapped) on the line, compute the envelope of nearby lattice points.
 * The envelope is generated by taking the snapped center and adding each neighbor direction,
 * then filtering out candidates whose Cartesian position is farther than tubeRadius from the center.
 *
 * Also computes the angular coordinate (in the plane perpendicular to the line) for sorting.
 *
 * @param {{x:number, y:number, z:number}} center - Unsnapped center along the line.
 * @returns {Array} Array of candidate envelope points, each as {six: number[], cartesian:{x,y,z}, angle: number}.
 */
function getEnvelopeCandidates(center) {
  // Get the snapped center.
  let snapped = snapToSixBasis(center);
  let centerCart = center; // unsnapped center in Cartesian.
  let candidates = [];
  // For each neighbor direction, compute candidate.
  for (let dir of neighborDirs) {
    let candidateSix = addSixVectors(snapped.six, dir);
    let candidateCart = sixBasisToCartesian(candidateSix);
    // Compute distance from candidate to the unsnapped center.
    let dx = candidateCart.x - centerCart.x;
    let dy = candidateCart.y - centerCart.y;
    let dz = candidateCart.z - centerCart.z;
    let dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
    if (dist <= tubeRadius) {
      // Compute offset from center and its angle in the plane defined by v1 and v2.
      let offset = { x: candidateCart.x - centerCart.x, y: candidateCart.y - centerCart.y, z: candidateCart.z - centerCart.z };
      let dot1 = offset.x * v1.x + offset.y * v1.y + offset.z * v1.z;
      let dot2 = offset.x * v2.x + offset.y * v2.y + offset.z * v2.z;
      let angle = Math.atan2(dot2, dot1);
      candidates.push({ six: candidateSix, cartesian: candidateCart, angle });
    }
  }
  // Sort candidates by angle.
  candidates.sort((a, b) => a.angle - b.angle);
  return candidates;
}

// ===== Build Envelope Rings Along the Tube =====

let envelopeRings = []; // one ring per section along the line.
for (let i = 0; i < numSections; i++) {
  let t = i / (numSections - 1);
  let center = interpolateLine(t);
  let candidates = getEnvelopeCandidates(center);
  // If no candidate is found, fallback to the snapped center (should rarely happen).
  if (candidates.length === 0) {
    candidates.push(snapToSixBasis(center));
  }
  envelopeRings.push(candidates);
}

// ===== Triangulation Between Envelope Rings =====

// For simplicity, if two adjacent rings have different numbers of points,
// we use the minimum count (i.e. only consider matching pairs by index).
let triangles = [];
for (let i = 0; i < envelopeRings.length - 1; i++) {
  let ringA = envelopeRings[i];
  let ringB = envelopeRings[i+1];
  let n = Math.min(ringA.length, ringB.length);
  // Assume the candidates are already sorted by angle.
  for (let j = 0; j < n; j++) {
    let jNext = (j + 1) % n;
    // Form two triangles per quadrilateral.
    triangles.push({
      vertices: [
        ringA[j].six,
        ringB[j].six,
        ringB[jNext].six
      ]
    });
    triangles.push({
      vertices: [
        ringA[j].six,
        ringB[jNext].six,
        ringA[jNext].six
      ]
    });
  }
}

// ===== Validation of Golden Geometry =====

/**
 * Computes Euclidean distance between two Cartesian points.
 *
 * @param {{x:number, y:number, z:number}} p1
 * @param {{x:number, y:number, z:number}} p2
 * @returns {number}
 */
function distance(p1, p2) {
  return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2 + (p1.z - p2.z)**2);
}

/**
 * Given three six‑vector vertices, convert to Cartesian, compute sorted edge lengths,
 * and decide if the triangle is a golden triangle (T) or a golden gnomon (G).
 * In a golden triangle the two longer (equal) edges have length ~φ times the short edge;
 * in a golden gnomon the two shorter (equal) edges have that relationship.
 *
 * @param {number[][]} sixVertices
 * @param {number} tol - Fractional tolerance.
 * @returns {{type: string, edges: number[]}}
 */
function validateTriangle(sixVertices, tol = 0.05) {
  const pts = sixVertices.map(v => sixBasisToCartesian(v));
  let d12 = distance(pts[0], pts[1]);
  let d23 = distance(pts[1], pts[2]);
  let d31 = distance(pts[2], pts[0]);
  let edges = [d12, d23, d31].sort((a, b) => a - b); // Lmin, Lmid, Lmax
  let Lmin = edges[0], Lmid = edges[1], Lmax = edges[2];
  let ratio = Lmax / Lmin;
  let ratioIsGolden = Math.abs(ratio - phi) / phi < tol;
  let lowerPairEqual = Math.abs(Lmin - Lmid) / Lmin < tol;
  let upperPairEqual = Math.abs(Lmax - Lmid) / Lmax < tol;
  let type = "?";
  if (ratioIsGolden) {
    if (upperPairEqual) {
      type = "T"; // golden triangle: two equal longer edges.
    } else if (lowerPairEqual) {
      type = "G"; // golden gnomon: two equal shorter edges.
    }
  }
  return { type, edges };
}

// ===== Output the Triangulation with Validation =====

console.log("Final Tiling (each triangle with type, edge lengths, and integer 6-vector vertices):");
triangles.forEach((tri, idx) => {
  let validation = validateTriangle(tri.vertices);
  console.log(`Triangle ${idx + 1} [Type: ${validation.type}]`);
  console.log(`  Edge lengths (sorted): ${validation.edges.map(l => l.toFixed(4)).join(", ")}`);
  tri.vertices.forEach((v, vi) => {
    console.log(`  Vertex ${vi + 1}: [${v.join(", ")}]`);
  });
});
